{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Syriinge","text":"<p>Syriinge is a framework and API for injecting C++ code into Super Smash Bros. Brawl at runtime via plugins.</p> <p>Syriinge's goal is to empower developers with the tools they need to execute grand and intricate coding projects without resorting to hand writing assembly by letting developers use C/C++ to write their mods.</p> <ul> <li> <p> Getting Started</p> <p>Learn how to install the Syriinge SDK and write your first plugin.</p> <p> Getting started</p> </li> <li> <p> API Reference</p> <p>Browse the API reference for guidance on Syriinge's core hooking API.</p> <p> Reference</p> </li> <li> <p> How It Works</p> <p>Curious how everything works under the hood?</p> <p> Technical Explanation</p> </li> <li> <p> Examples and Templates</p> <p>Find reference projects and samples to jumpstart your journey.</p> <p> Examples</p> </li> </ul>"},{"location":"patches/","title":"Patch Files","text":"<p>Not Implemented</p> <p>This feature is not currently implemented.</p> <p>While working with Syriinge, you might ocassionally run into situations where you want to patch a large volume of memory with some data. You could write a function in your plugin that just loads the file from the SD and <code>memcpy</code>'s the data to the address you want, but there is a better way.</p>"},{"location":"patches/#introducing-patches","title":"Introducing Patches","text":"<p>Patch Files are binary files tagged with metadata such as a target address or addresses and when to apply the patch.</p> <p>Just like with hooks, Patches can be constructed such that they are only applied when a specific module is loaded or reloaded. </p> <p>Likewise, they can also be configured to just apply the patch once.</p>"},{"location":"patches/#using-patch-files","title":"Using Patch Files","text":"<p>Patch Files are loaded from the <code>patches</code> directory in your build's <code>pf</code> folder.</p>"},{"location":"patches/#creating-patch-files","title":"Creating Patch Files","text":"<p>TODO</p>"},{"location":"API/","title":"API Overview","text":""},{"location":"API/#coreapi","title":"CoreAPI","text":"<p>In order for plugins to utilize Syriinge, it needs access to the Syriinge API. Syriinge provides API access to plugins by way of the CoreAPI object. Plugins use this object to register hooks, subscribe to events, and more. </p> <p>The entrypoint to every plugin (by default called <code>_prolog</code>) takes a single parameter, which is a pointer to the CoreAPI instance. </p> <p>To learn more about CoreAPI and how to use it, take a look at the CoreAPI page.</p>"},{"location":"API/#plugin-metadata","title":"Plugin Metadata","text":"<p>Every plugin contains a PluginMeta definition. This structure is used by the developer to detail information such as the plugin version, the syriinge runtime it was built for, the plugin author, and other misc. information. </p> <p>You can learn more about the specific fields, what they do, and how to define the object in PluginMeta.</p>"},{"location":"API/#hooks","title":"Hooks","text":"<p>The API is the plugin developers main way of interacting with and registering hooks with Syriinge. Through this API, a developer can hook specific offsets within a function or even replace a function outright.</p> <p>Syriinge provides two methods of hooking for each hook type. Static and Relative. The Relative hooking functions are used for hooking rels, as the name suggests, and hooks registered with it are applied when the target rel loads.</p> <p>Static hooks are applied during the plugin load and are active immediately.</p> <p>You can find a complete list of hooking functions in the API Reference. </p>"},{"location":"API/#events","title":"Events","text":"<p>Syriinge offers developers the opportunity to register a callback function to be called when a number of events take place, such as when a rel is loaded. </p> <p>Using this system developers can detect the presence of other plugins, get access to rels as they are loaded, run routines on game events like match start, and more.</p> <p>For more details on Events and Event Handling look at the Event Handling Guide</p>"},{"location":"API/CoreAPI/","title":"CoreAPI","text":""},{"location":"API/CoreAPI/#overview","title":"Overview","text":"<p>The CoreAPI instance is the primary contact point between the Syriinge core and plugins. Plugins use this instance to register hooks and subscribe to game or syriinge events.</p> <p>Every plugin receives a pointer to this API object as a parameter to the main plugin entrypint (<code>_prolog</code>). </p>"},{"location":"API/CoreAPI/#static-hooking-vs-rel-hooking","title":"Static Hooking vs Rel Hooking","text":"<p>There are two ways to inject hooks with Syriinge. Static hooking and Rel Hooking.</p> <p>Static Hooks are hooks which are applied immediately upon plugin load and are never re-applied. This is primarily used for hooking <code>main.dol</code> as it never changes.</p> <p>Rel Hooks are hooks that get applied any time the target rel is loaded into memory by the game.</p>"},{"location":"API/CoreAPI/#static-hooking-methods","title":"Static Hooking Methods","text":"<ul> <li>syInlineHook</li> <li>sySimpleHook</li> <li>syReplaceFunc</li> </ul>"},{"location":"API/CoreAPI/#relative-hooking-methods","title":"Relative Hooking Methods","text":"<ul> <li>syInlineHookRel</li> <li>sySimpleHookRel</li> <li>syReplaceFuncRel</li> </ul>"},{"location":"API/CoreAPI/#event-handling-methods","title":"Event Handling Methods","text":"<ul> <li>moduleLoadEventSubscribe</li> </ul>"},{"location":"API/CoreAPI/#additional-resources","title":"Additional Resources","text":""},{"location":"API/CoreAPI/#guides","title":"Guides","text":"<ul> <li>Inline Hooking</li> <li>Simple Hooks</li> <li>Replacing Funcs</li> <li>Event Handling</li> </ul>"},{"location":"API/PluginMeta/","title":"PluginMeta","text":""},{"location":"API/PluginMeta/#overview","title":"Overview","text":"<p>Every plugin must define a <code>PluginMeta</code> structure. This structure is used to define the plugin version, the runtime version it was built for, the plugin author, etc.</p> <p>The <code>_prolog</code> function should return a reference to this instance.</p>"},{"location":"API/PluginMeta/#definition","title":"Definition","text":"<pre><code>struct PluginMeta {\n    char NAME[20];\n    char AUTHOR[20];\n    Version VERSION;\n    Version SY_VERSION;\n};\n</code></pre>"},{"location":"API/PluginMeta/#example-usage","title":"Example Usage","text":"<p>In following example, you can see two uses of the <code>Version</code> type that Syriinge provides. This type takes a string of the format <code>major.minor.rev</code>. </p> <p>The type has operator functions for comparing two instances against eachother.</p> <p>We also use the <code>SYRINGE_VERSION</code> define for the core version / runtime. This define is present in every Syriinge SDK and should be used here to ensure your metadata always matches the SDK you are compiling with. <pre><code>    const PluginMeta META = {\n        \"Sandbox\",               // name\n        \"Sammi\",                 // author\n        Version(\"1.0.0\"),        // version\n        Version(SYRINGE_VERSION) // core version\n    };\n\n    const PluginMeta* __prolog(CoreApi* api)\n    {\n        // Run global constructors\n        PFN_voidfunc* ctor;\n        for (ctor = _ctors; *ctor; ctor++)\n        {\n            (*ctor)();\n        }\n\n        // Do hooking here with api\n        // ...\n\n        return &amp;META;\n    }\n</code></pre></p>"},{"location":"API/hooks/inline-hook-rel/","title":"syInlineHookRel","text":""},{"location":"API/hooks/inline-hook-rel/#signature","title":"Signature","text":"<pre><code>virtual void syInlineHookRel(const u32 offset, const void* replacement, int moduleId);\n</code></pre>"},{"location":"API/hooks/inline-hook-rel/#parameters","title":"Parameters","text":"Parameter Type Description <code>address</code> u32 The address to hook <code>replacement</code> void* function pointer to the hook body <code>moduleId</code> int The ID of the rel to inject into"},{"location":"API/hooks/inline-hook-rel/#description","title":"Description","text":"<p>Relative Hooking version of syInlineHook</p>"},{"location":"API/hooks/inline-hook-rel/#example-usage","title":"Example Usage","text":"<pre><code>void sayHello() {\n    OSReport(\"Hello World!\\n\");\n}\n\nvoid Init(CoreAPI* api) {\n    // Inject our hook into the module with ID 0x1b at offset 0x1E00\n    api-&gt;syInlineHookRel(0x1E00, reinterpret_cast&lt;void*&gt;(sayHello), 0x1b);\n}\n</code></pre>"},{"location":"API/hooks/inline-hook/","title":"syInlineHook","text":""},{"location":"API/hooks/inline-hook/#signature","title":"Signature","text":"<pre><code>virtual void syInlineHook(const u32 address, const void* replacement);\n</code></pre>"},{"location":"API/hooks/inline-hook/#parameters","title":"Parameters","text":"Parameter Type Description <code>address</code> u32 The address to hook <code>replacement</code> void* function pointer to the hook body"},{"location":"API/hooks/inline-hook/#description","title":"Description","text":"<p>Injects a hook at the target address. </p> <ul> <li>Hooks injected via this method WILL return execution to the original function. </li> <li>Register values prior to branching to your code are restored when returning. </li> <li>These hooks will run the overwritten instruction at <code>address</code> prior to jumping to your code.</li> </ul>"},{"location":"API/hooks/inline-hook/#example-usage","title":"Example Usage","text":"<pre><code>void sayHello() {\n    OSReport(\"Hello World!\\n\");\n}\n\nvoid Init(CoreAPI* api) {\n    api-&gt;syInlineHook(0x8000c8b8, reinterpret_cast&lt;void*&gt;(sayHello));\n}\n</code></pre>"},{"location":"API/hooks/replace-func-rel/","title":"syReplaceFuncRel","text":""},{"location":"API/hooks/replace-func-rel/#signature","title":"Signature","text":"<pre><code>virtual void syReplaceFuncRel(const u32 offset, const void* replacement, void** original, int moduleId);\n</code></pre>"},{"location":"API/hooks/replace-func-rel/#parameters","title":"Parameters","text":"Parameter Type Description <code>address</code> u32 The address to hook <code>replacement</code> void* Pointer to hook code to inject <code>original</code> void** Pointer to a function pointer that will get set to the original unhooked function <code>moduleId</code> int The ID of the rel to inject into"},{"location":"API/hooks/replace-func-rel/#description","title":"Description","text":"<p>Relative Hooking version of syReplaceFunc</p>"},{"location":"API/hooks/replace-func-rel/#example-usage","title":"Example Usage","text":"<pre><code>int (*originalFunc)(void);\nint myFunc() {\n    OSReport(\"Hello World\\n\");\n    return originalFunc();\n}\n\nvoid Init(CoreAPI* api) {\n    // NOTE: Execution does not return to hook location.\n    // Inject our hook at offset 0x1DFC in the rel that's ID is 0x1b\n    api-&gt;syReplaceFunc(0x1DFC, \n                       reinterpret_cast&lt;void*&gt;(myFunc), \n                       reinterpret_cast&lt;void**&gt;(originalFunc),\n                       0x1b);\n}\n</code></pre>"},{"location":"API/hooks/replace-func/","title":"syReplaceFunc","text":""},{"location":"API/hooks/replace-func/#signature","title":"Signature","text":"<pre><code>virtual void syReplaceFunc(const u32 address, const void* replacement, void** original);\n</code></pre>"},{"location":"API/hooks/replace-func/#parameters","title":"Parameters","text":"Parameter Type Description <code>address</code> u32 The address to hook <code>replacement</code> void* Pointer to hook code to inject <code>original</code> void** Pointer to a function pointer that will get set to the original unhooked function"},{"location":"API/hooks/replace-func/#description","title":"Description","text":"<p>Injects a hook over the first instruction of a function. The <code>original</code> paramter will get set to a pointer to the unmodified original function. This is useful for calling the original behavior from within your replacement.</p> <p>Retuning from your replacement will return to the function caller, not the replaced function.</p>"},{"location":"API/hooks/replace-func/#example-usage","title":"Example Usage","text":"<pre><code>int (*originalFunc)(void);\nint myFunc() {\n    OSReport(\"Hello World\\n\");\n    return originalFunc();\n}\n\nvoid Init(CoreAPI* api) {\n    // NOTE: Execution does not return to hook location.\n    api-&gt;syReplaceFunc(0x8000c8b8, \n                       reinterpret_cast&lt;void*&gt;(myFunc), \n                       reinterpret_cast&lt;void**&gt;(originalFunc));\n}\n</code></pre>"},{"location":"API/hooks/simple-hook-rel/","title":"sySimpleHookRel","text":"<p>Warning</p> <p>Register context of the hooked function is not preserved with this method. Hooks will clobber the volatile registers.</p> <p>Warning</p> <p>The overwritten instruction at <code>address</code> is not run or preserved.</p>"},{"location":"API/hooks/simple-hook-rel/#signature","title":"Signature","text":"<pre><code>virtual void sySimpleHookRel(const u32 offset, const void* replacement, int moduleId);\n</code></pre>"},{"location":"API/hooks/simple-hook-rel/#parameters","title":"Parameters","text":"Parameter Type Description <code>address</code> u32 The address to hook <code>replacement</code> void* function pointer to the hook body <code>moduleId</code> int The ID of the rel to inject into"},{"location":"API/hooks/simple-hook-rel/#description","title":"Description","text":"<p>Relative Hooking version of sySimpleHook</p>"},{"location":"API/hooks/simple-hook-rel/#example-usage","title":"Example Usage","text":"<pre><code>asm void myFunc() {\n    // Don't need a stack frame.\n    nofralloc\n\n    // Return 0\n    li r3, 0\n    blr\n}\n\nvoid Init(CoreAPI* api) {\n    // NOTE: Execution does not return to hook location\n    // Inject our hook at offset 0x1fec into the module whose ID matches 0x1b\n    api-&gt;sySimpleHook(0x1fec, reinterpret_cast&lt;void*&gt;(myFunc), 0x1b);\n}\n</code></pre>"},{"location":"API/hooks/simple-hook/","title":"sySimpleHook","text":"<p>Warning</p> <p>Register context of the hooked function is not preserved with this method. Hooks will clobber the volatile registers.</p> <p>Warning</p> <p>The overwritten instruction at <code>address</code> is not run or preserved.</p>"},{"location":"API/hooks/simple-hook/#signature","title":"Signature","text":"<pre><code>virtual void sySimpleHook(const u32 address, const void* replacement);\n</code></pre>"},{"location":"API/hooks/simple-hook/#parameters","title":"Parameters","text":"Parameter Type Description <code>address</code> u32 The address to hook <code>replacement</code> void* function pointer to the hook body"},{"location":"API/hooks/simple-hook/#description","title":"Description","text":"<p>Injects a hook at the target address. Hooks injected via this method will NOT return execution to the original function by default. </p> <p>This hook type is commonly used for raw asm functions.</p>"},{"location":"API/hooks/simple-hook/#example-usage","title":"Example Usage","text":"<pre><code>asm void myFunc() {\n    // Don't need a stack frame.\n    nofralloc\n\n    // Return 0\n    li r3, 0\n    blr\n}\n\nvoid Init(CoreAPI* api) {\n    // NOTE: Execution does not return to hook location\n    api-&gt;sySimpleHook(0x8000c8b8, reinterpret_cast&lt;void*&gt;(myFunc));\n}\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will get you familiar with the basic plumbing and steps required to get a bare-bones plugin written and loaded into the game as quickly as possible.</p> <p>For the purposes of this guide, we are going to assume that you know the basics of managing a brawl build / modpack, and are familiar with how to add codes to your GCT.</p>"},{"location":"getting-started/quick-start/#installing-the-runtime","title":"Installing the runtime","text":"<ol> <li>Download a release build from the Project Repository, making sure to choose a \"USER\" zip. <ul> <li>Alternatively, you can also build from source</li> </ul> </li> <li>Mount your dolphin virtual SD, or insert your physical SD into your PC.</li> <li>Copy the contents of the previously downloaded zip file to the root of your build. (e.g <code>sd:/project+/</code>)</li> <li>Link the included <code>.asm</code> files into your RSBE01.txt file and then recompile the codeset. <ul> <li>These codes MUST be in RSBE01 and not BOOST.</li> </ul> </li> <li>Done! You should now have a functioning Syriinge install, ready to load plugins.</li> </ol>"},{"location":"getting-started/quick-start/#setting-up-the-project","title":"Setting up the project","text":""},{"location":"getting-started/quick-start/#required-components","title":"Required Components","text":"<ul> <li>DevKitPro</li> <li>git</li> </ul>"},{"location":"getting-started/quick-start/#syriinge-plugin-template","title":"Syriinge Plugin Template","text":"<p>To streamline the creation of plugins, a Template Repository has been created that scaffolds out a basic barebones \"Hello World\" example. For simplicity, we'll be using this repository to boostrap our development and explaining the individual parts as we go.</p> <pre><code>// Checkout the plugin repo\ngit checkout https://github.com/Sammi-Husky/SyriingePluginTemplate.git\n\n// Move into the folder\ncd SyriingePluginTemplate\n\n// Build the plugin\nmake\n</code></pre> <p>If you followed the above steps and have the required components installed (and in your system path) you should end up with a built <code>.rel</code> plugin file to confirm that everything is working properly.</p>"},{"location":"getting-started/quick-start/#anatomy-of-a-plugin","title":"Anatomy of a Plugin","text":"<p>Now that we've got a solid boilerplate to base our plugin on, lets dive into each file and explain what they do.</p>"},{"location":"getting-started/quick-start/#makefile","title":"Makefile","text":"<p>To anyone versed in C/C++ development, Makefiles are an infamous if uniquitous part of your life. For the uninitiated, this file is responsible for holding the instructions for building your project. </p> <p>It compiles and links your code, and in our case uses <code>elf2rel</code> on it to generated a plugin file. There are also several configuration options contained in this file:</p> <ul> <li>TARGET<ul> <li>This is the name of the plugin being built. The <code>.rel</code> file will be named whatever this is set to.</li> </ul> </li> <li>RELID<ul> <li>This denotes the ID of the <code>.rel</code> file.</li> </ul> </li> <li>SOURCES <ul> <li>list of directories containing source files to be compiled.</li> </ul> </li> </ul>"},{"location":"getting-started/quick-start/#extralst","title":"EXTRA.lst","text":"<p>Part of the build process for making <code>.rel</code> plugins is to partially link the compiled objects. This results in a great number of unresolved references. </p> <p>Thankfully, we can pass this partially linked binary into a tool called <code>elf2rel</code> along with a supplied mapping file (<code>.lst</code>) that maps symbols to addresses. </p> <p><code>elf2rel</code> will use this map to resolve as many unresolved references as possible, and then convert the elf file into a <code>.rel</code> that is loadable by Syriinge.</p>"},{"location":"getting-started/quick-start/#rellcf","title":"rel.lcf","text":"<p>This is the MWCC equivalent of the linkerscript. There is some metrowerks specific syntax going on here, but thankfully this doesn't need to be edited for 90% of usecases so we won't go into detail here.</p>"},{"location":"getting-started/quick-start/#relcpp","title":"rel.cpp","text":"<p>This is the main entrypoint to the plugin. This file contains three functions:</p> <ul> <li>_prolog</li> <li>_epilog</li> <li>_unresolved</li> </ul>"},{"location":"getting-started/quick-start/#_prolog","title":"_prolog","text":"<p>The _prolog function is called automatically by the <code>sy_core</code> loader when loading plugins. </p> <p>It recieves a single parameter, which is a pointer to the CoreAPI object. All hooking and API interactions are done via this object. <code>_prolog</code> is also responsible for iterating over and calling all the static initializer functions from the <code>.ctor</code> section. These are typically auto-generated.</p>"},{"location":"getting-started/quick-start/#_epilog","title":"_epilog","text":"<p>Similarly to the _prolog function, this function is called automatically when a <code>.rel</code> is unloaded by the game. This function is responsible for calling the destructors for all static objects in rel one by one. These destructors are in the <code>.dtor</code>, and are typically auto-generated.</p>"},{"location":"getting-started/quick-start/#_unresolved","title":"_unresolved","text":"<p>This function is what is any remaining unresolved references that were not resolved in the <code>elf2rel</code> linking step will point to. Typically, this function is used to log the name of the module or file that the unresolved reference originates from.</p>"},{"location":"getting-started/quick-start/#further-reading","title":"Further Reading","text":"<p>You should now have a good understanding of the boilerplate that is provided to you by the Template Repository. </p> <p>The next step is to build a simple \"Hello World\" application which you can follow our basic Tutorial Guide to do.</p>"}]}