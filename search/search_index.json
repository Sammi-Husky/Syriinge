{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Syriinge","text":"<p>Syriinge is a framework and API for injecting C++ code into Super Smash Bros. Brawl at runtime via plugins.</p> <p>Syriinge's goal is to empower developers with the tools they need to execute grand and intricate coding projects without resorting to hand writing assembly by letting developers use C/C++ to write their mods.</p> <ul> <li> <p> Getting Started</p> <p>Learn how to install the Syriinge SDK and write your first plugin.</p> <p> Getting started</p> </li> <li> <p> API Reference</p> <p>Browse the API reference for guidance on Syriinge's core hooking API.</p> <p> Reference</p> </li> <li> <p> How It Works</p> <p>Curious how everything works under the hood?</p> <p> Technical Explanation</p> </li> <li> <p> Examples and Templates</p> <p>Find reference projects and samples to jumpstart your journey.</p> <p> License</p> </li> </ul>"},{"location":"patches/","title":"Patch Files","text":"<p>Not Implemented</p> <p>This feature is not currently implmeented.</p> <p>While working with Syriinge, you might ocassionally run into situations where you want to patch a large volume of memory with some data. You could write a function in your plugin that just loads the file from the SD and <code>memcpy</code>'s the data to the address you want, but there is a better way.</p>"},{"location":"patches/#introducing-patches","title":"Introducing Patches","text":"<p>Patch Files are binary files tagged with metadata such as a target address or addresses and when to apply the patch.</p> <p>Just like with hooks, Patches can be constructed such that they are only applied when a specific module is loaded or reloaded. </p> <p>Likewise, they can also be configured to just apply the patch once.</p>"},{"location":"patches/#using-patch-files","title":"Using Patch Files","text":"<p>Patch Files are loaded from the <code>patches</code> directory in your build's <code>pf</code> folder.</p>"},{"location":"patches/#creating-patch-files","title":"Creating Patch Files","text":"<p>TODO</p>"},{"location":"API/","title":"API Reference","text":""},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will get you familiar with the basic plumbing and steps required to get a bare-bones plugin written and loaded into the game as quickly as possible.</p> <p>For the purposes of this guide, we are going to assume that you know the basics of managing a brawl build / modpack, and are familiar with how to add codes to your GCT.</p>"},{"location":"getting-started/quick-start/#installing-the-runtime","title":"Installing the runtime","text":"<ol> <li>Download a release build from the Project Repository, making sure to choose a \"USER\" zip. <ul> <li>Alternatively, you can also build from source</li> </ul> </li> <li>Mount your dolphin virtual SD, or insert your physical SD into your PC.</li> <li>Copy the contents of the previously downloaded zip file to the root of your build. (e.g <code>sd:/project+/</code>)</li> <li>Link the included <code>.asm</code> files into your RSBE01.txt file and then recompile the codeset. <ul> <li>These codes MUST be in RSBE01 and not BOOST.</li> </ul> </li> <li>Done! You should now have a functioning Syriinge install, ready to load plugins.</li> </ol>"},{"location":"getting-started/quick-start/#setting-up-the-project","title":"Setting up the project","text":""},{"location":"getting-started/quick-start/#required-components","title":"Required Components","text":"<ul> <li>DevKitPro</li> <li>git</li> </ul>"},{"location":"getting-started/quick-start/#syriinge-plugin-template","title":"Syriinge Plugin Template","text":"<p>To streamline the creation of plugins, a Template Repository has been created that scaffolds out a basic barebones \"Hello World\" example. For simplicity, we'll be using this repository to boostrap our development and explaining the individual parts as we go.</p> <pre><code>// Checkout the plugin repo\ngit checkout https://github.com/Sammi-Husky/SyriingePluginTemplate.git\n\n// Move into the folder\ncd SyriingePluginTemplate\n\n// Build the plugin\nmake\n</code></pre> <p>If you followed the above steps and have the required components installed (and in your system path) you should end up with a built <code>.rel</code> plugin file to confirm that everything is working properly.</p>"},{"location":"getting-started/quick-start/#anatomy-of-a-plugin","title":"Anatomy of a Plugin","text":"<p>Now that we've got a solid boilerplate to base our plugin on, lets dive into each file and explain what they do.</p>"},{"location":"getting-started/quick-start/#makefile","title":"Makefile","text":"<p>To anyone versed in C/C++ development, Makefiles are an infamous if uniquitous part of your life. For the uninitiated, this file is responsible for holding the instructions for building your project. </p> <p>It compiles and links your code, and in our case uses <code>elf2rel</code> on it to generated a plugin file. There are also several configuration options contained in this file:</p> <ul> <li>TARGET<ul> <li>This is the name of the plugin being built. The <code>.rel</code> file will be named whatever this is set to.</li> </ul> </li> <li>RELID<ul> <li>This denotes the ID of the <code>.rel</code> file.</li> </ul> </li> <li>SOURCES <ul> <li>list of directories containing source files to be compiled.</li> </ul> </li> </ul>"},{"location":"getting-started/quick-start/#extralst","title":"EXTRA.lst","text":"<p>Part of the build process for making <code>.rel</code> plugins is to partially link the compiled objects. This results in a great number of unresolved references. </p> <p>Thankfully, we can pass this partially linked binary into a tool called <code>elf2rel</code> along with a supplied mapping file (<code>.lst</code>) that maps symbols to addresses. </p> <p><code>elf2rel</code> will use this map to resolve as many unresolved references as possible, and then convert the elf file into a <code>.rel</code> that is loadable by Syriinge.</p>"},{"location":"getting-started/quick-start/#rellcf","title":"rel.lcf","text":"<p>This is the MWCC equivalent of the linkerscript. There is some metrowerks specific syntax going on here, but thankfully this doesn't need to be edited for 90% of usecases so we won't go into detail here.</p>"},{"location":"getting-started/quick-start/#relcpp","title":"rel.cpp","text":"<p>This is the main entrypoint to the plugin. This file contains three functions:</p> <ul> <li>prolog</li> <li>epilog</li> <li>unresolved</li> </ul>"},{"location":"getting-started/quick-start/#prolog","title":"prolog","text":"<p>The prolog function is called automatically by the <code>sy_core</code> loader when loading plugins. </p> <p>It recieves a single parameter, which is a pointer to the CoreAPI object. All hooking and API interactions are done via this object. <code>prolog</code> is also responsible for iterating over and calling all the static initializer functions from the <code>.ctor</code> section. These are typically auto-generated.</p>"},{"location":"getting-started/quick-start/#epilog","title":"epilog","text":"<p>Similarly to the prolog function, this function is called automatically when a <code>.rel</code> is unloaded by the game. This function is responsible for calling the destructors for all static objects in rel one by one. These destructors are in the <code>.dtor</code>, and are typically auto-generated.</p>"},{"location":"getting-started/quick-start/#unresolved","title":"unresolved","text":"<p>This function is what is any remaining unresolved references that were not resolved in the <code>elf2rel</code> linking step will point to. Typically, this function is used to log the name of the module or file that the unresolved reference originates from.</p>"}]}